{{define "Builder" -}}{{with $root := .}}{{with $target := ($root.Target.Name) -}}
// Generated by {{$root.GeneratedBy}} {{$root.SysArgs}}

package {{$root.PkgName}}

import (
	"fmt"
	"sync"
{{if $root.NeedStringer}}	"io"{{end -}}
{{range $_, $im := $root.Imports}}
	{{if (not (eq $im.Name ""))}}{{$im.Name}} {{end}}{{$im.Path | printf "%q"}}
{{end -}}
)

type {{$target}}Builder interface {
	Get{{$target}}Metadata() *{{$target}}Metadata
{{if $root.NeedStringer}}	write{{$target}}(io.Writer) error  // see: ./stringer.go{{end -}}
{{range $_, $m := $root.InterfaceMethods}}
	{{$m -}}
{{end}}
}

// Define names {{$target}} value.
func Define[T interface {
	{{$target}}Builder
	store{{$target}}(name string)
}](name string, t T) T {
	t.store{{$target}}(name)
	return t
}

type Builder struct {
	mu          	sync.Mutex
	named{{$target}}s  []{{$target}}Builder
	nameToIDMap map[string][]int
{{- range $_, $f := $root.Fields}}
	{{if (not (eq "" $f.Doc))}}{{$f.Doc}}{{end}}
	{{$f.Name}} {{$f.Type}}{{if (not (eq $f.Tag ""))}}  `{{$f.Tag}}`{{end}}
{{end}}
}

func NewBuilder({{if (not (eq $root.Constructor nil))}}{{range $_,$a := $root.Constructor.Args}}{{$a.Name | toLower}} {{if $a.Variadic}}...{{end}}{{$a.Type}},{{end}}{{end}}) *Builder {
	return &Builder{
		nameToIDMap: map[string][]int{},
		named{{$target}}s: []{{$target}}Builder{nil},  // nil is sentinel (id<=0 is unnamed)
		{{if (not (eq $root.Constructor nil))}}{{range $_,$a := $root.Constructor.Args}}{{$a.Name}}: {{$a.Name | toLower}}, {{end}}{{end}}
	}
}

// Each{{$target}} iterates named {{$target}}.
func (b *Builder) Each{{$target}}s(fn func({{$target}}Builder) error) error {
	for _, t := range b.named{{$target}}s {
		if t == nil {
			continue
		}
		if err := fn(t); err != nil {
			return fmt.Errorf("error on %v -- %w", t, err) // TODO: use ToString()
		}
	}
	return nil
}

func (b *Builder) store{{$target}}(typ {{$target}}Builder) {
	val := typ.Get{{$target}}Metadata()
	val.id = -1
	if val.Name == "" {
		return
	}

	b.mu.Lock()
	defer b.mu.Unlock()
	id := len(b.named{{$target}}s)
	val.id = id
	b.named{{$target}}s = append(b.named{{$target}}s, typ)
	b.nameToIDMap[val.Name] = append(b.nameToIDMap[val.Name], id)
	// TODO: name conflict check
}

func (b *Builder) lookup{{$target}}(name string) {{$target}}Builder {
	b.mu.Lock()
	defer b.mu.Unlock()
	ids, ok := b.nameToIDMap[name]
	if !ok {
		b.nameToIDMap[name] = nil
		return nil
	}
	if len(ids) == 0 {
		return nil
	}

	// TODO: name conflict check
	return b.named{{$target}}s[ids[0]]
}

{{if $root.NeedReference}}

func (b *Builder) ReferenceByName(name string) *{{$target}}Ref {
	return &{{$target}}Ref{Name: name, rootbuilder: b}
}
func (b *Builder) Reference(typ {{$target}}Builder) *{{$target}}Ref {
	name := typ.Get{{$target}}Metadata().Name
	return &{{$target}}Ref{Name: name, rootbuilder: b, _{{$target}}: typ}
}

type {{$target}}Ref struct {
	Name string
	_{{$target}} {{$target}}Builder

	rootbuilder *Builder
}

func (t *{{$target}}Ref) get{{$target}}() {{$target}}Builder {
	if t._{{$target}} != nil {
		return t._{{$target}}
	}
	t._{{$target}} = t.rootbuilder.lookup{{$target}}(t.Name)
	return t._{{$target}}
}
func (t *{{$target}}Ref) Get{{$target}}Metadata() *{{$target}}Metadata {
	return t.get{{$target}}().Get{{$target}}Metadata()
}
{{end}}

{{range $_, $t := $root.Types}}{{with $name := ($t.Name)}}
{{if $t.NeedBuilder }}
// {{$name}} builds {{$target}} for {{$name}}
func (b *Builder) {{$name}}({{range $_, $tv := $t.TVars}}{{$tv.Name | toLower}} {{$tv.Type}}, {{end}}{{if (not (eq $t.Constructor nil))}}{{range $_,$a := $t.Constructor.Args}}{{$a.Name | toLower}} {{if $a.Variadic}}...{{end}}{{$a.Type}},{{end}}{{end}}) *{{$name}}{{if (lt 0 (len $t.TVars))}}[{{$t.TVars.Types}}]{{end}} {
	t := &{{$name}}{{if (lt 0 (len $t.TVars))}}[{{$t.TVars.Types}}]{{end}}{
		_{{$name}}Builder: &_{{$name}}Builder[{{$t.TVars.Types}}*{{$name}}{{if (lt 0 (len $t.TVars))}}[{{$t.TVars.Types}}]{{end}}]{
			_{{$target}}:    &_{{$target}}[*{{$name}}{{if (lt 0 (len $t.TVars))}}[{{$t.TVars.Types}}]{{end}}]{rootbuilder: b, metadata: &{{$target}}Metadata{Name: "", underlying: {{$t.Underlying | printf "%q"}}, goType: {{$t.GoType| printf "%q"}}}},
			metadata: &{{$name}}Metadata{
				{{if (not (eq $t.Constructor nil))}}{{range $_,$a := $t.Constructor.Args}}{{if eq 1 (len $a.BindFields)}}{{$a.Name}}: {{if $a.Transform}}{{call $a.Transform (toLower $a.Name)}}{{else}}{{$a.Name | toLower}}{{end}}, {{end}}{{end}}{{end}}
				{{range $_, $f := $t.Fields}}{{if (not (eq "" $f.Default))}}{{$f.Name}}: {{$f.Default}}, {{end}}{{end}}
			},
			{{range $_, $tv := $t.TVars}}{{$tv.Name | toLower}}: {{$tv.Name | toLower}}, {{end}}
		},
	}
	{{if (not (eq $t.Constructor nil))}}{{range $_,$a := $t.Constructor.Args}}{{if (lt 1 (len $a.BindFields))}}{{with $lastIndex := (lastIndex $a.BindFields)}}
	{{range $i,$f := $a.BindFields}}t.metadata.{{$f}}{{if (eq $i $lastIndex)}} = {{else}}, {{end}}{{end}}{{if $a.Transform}}{{call $a.Transform (toLower $a.Name)}}{{else}}{{$a.Name | toLower}}{{end}}
	{{end}}{{end}}{{end}}{{end -}}
	t.ret = t
	return t
}

type {{$name}}{{if (lt 0 (len $t.TVars))}}[{{$t.TVars.NameAndTypes}}]{{end}} struct {
	*_{{$name}}Builder[{{$t.TVars.Names}}*{{$name}}{{if (lt 0 (len $t.TVars))}}[{{$t.TVars.Names}}]{{end}}]
}

func (t *{{$name}}{{if (lt 0 (len $t.TVars))}}[{{$t.TVars.Names}}]{{end}}) GetMetadata() *{{$name}}Metadata {
	return t.metadata
}

type _{{$name}}Builder[{{$t.TVars.NameAndTypes}}R {{$target}}Builder] struct {
	*_{{$target}}[R]
	metadata *{{$name}}Metadata

{{- range $_, $tv := $t.TVars}}
	{{$tv.Name | toLower}} {{$tv.Name}}
{{end}}
}

{{if (lt 0 (len $t.Fields))}}
// begin setter of {{$name}} --------------------
{{range $_, $f := $t.Fields}}{{if (not (index $t.Used $f.Name))}}
// {{$f.Name}} set Metadata.{{$f.Name}}
func (b *_{{$name}}Builder[{{$t.TVars.Names}}R]) {{$f.Name}}(value {{$f.Type}}) R {
	b.metadata.{{$f.Name}} = value
	return b.ret
}
{{end}}{{end}}
{{range $_, $s := $t.Setters}}{{with $a := $s.Arg}}
func (b *_{{$name}}Builder[{{$t.TVars.Names}}R]) {{$s.Name}}({{$a.Name | toLower}} {{if $a.Variadic}}...{{end}}{{$a.Type}}) R {
	b.metadata.{{$s.Name}} = {{if $a.Transform}}{{call $a.Transform (toLower $a.Name)}}{{else}}{{$a.Name | toLower}}{{end}}
	return b.ret
}
{{end}}{{end}}
// end setter of {{$name}} --------------------
{{end -}}

{{else}}
{{end}}
{{end}}{{end -}}

// internal {{$target}}

type _{{$target}}[R {{$target}}Builder] struct {
	metadata *{{$target}}Metadata
	ret      R

	rootbuilder *Builder
}

func (t *_{{$target}}[R]) Get{{$target}}Metadata() *{{$target}}Metadata {
	return t.metadata
}

{{if (lt 0 (len $root.Target.Fields))}}
// begin setter of {{$target}} --------------------
{{range $_, $f := $root.Target.Fields}}{{if (not (index $root.Target.Used $f.Name))}}
// {{$f.Name}} set Metadata.{{$f.Name}}
func (t _{{$target}}[R]) {{$f.Name}}(value {{$f.Type}}) R {
	t.metadata.{{$f.Name}} = value
	return t.ret
}
{{end}}{{end}}
{{range $_, $s := $root.Target.Setters}}{{with $a := $s.Arg}}
func (t _{{$target}}[R]) {{$s.Name}}({{$a.Name | toLower}} {{if $a.Variadic}}...{{end}}{{$a.Type}}) R {
	t.metadata.{{$s.Name}} = {{if $a.Transform}}{{call $a.Transform (toLower $a.Name)}}{{else}}{{$a.Name | toLower}}{{end}}
	return t.ret
}
{{end}}{{end}}
// end setter of {{$target}} --------------------
{{end -}}

func (t *_{{$target}}[R]) store{{$target}}(name string) {
	t.metadata.Name = name
	t.rootbuilder.store{{$target}}(t.ret)
}
{{if (lt 0 (len $root.UnionTypes))}}{{range $_, $ut := $root.UnionTypes}}
// {{$ut.Type.Name}} is the one of pseudo sum types (union).
{{if (not (eq "" $ut.Type.Doc))}}{{$ut.Type.Doc}}{{end}}
type {{$ut.Type.Name}} interface {
	{{$ut.DistinguishID}}()
{{range $_, $m := $ut.InterfaceMethods}}
	{{$m -}}
{{end}}
}
{{range $_, $t := $ut.Args}}{{with $name := ($t.Name)}}
func (t *{{$name}}{{if (lt 0 (len $t.TVars))}}[{{$t.TVars.Names}}]{{end}}) {{$ut.DistinguishID}}() {}
{{end}}{{end}}
{{if $ut.NeedReference}}func (t *{{$target}}Ref) {{$ut.DistinguishID}}() {}{{end}}
{{end}}{{end -}}
{{if $root.Footer}}

// footer. ----
{{$root.Footer}}
{{end}}
{{end}}{{end}}{{end -}}
--------------------------------------------------------------------------------

{{define "Metadata" -}}{{with $root := .}}{{with $target := ($root.Target.Name) -}}
// Generated by {{$root.GeneratedBy}} {{$root.SysArgs}}

package {{$root.PkgName}}
{{if (not (eq 0 (len $root.ImportsInMetadata)))}}

import (
{{range $_, $im := $root.ImportsInMetadata}}
	{{if (not (eq $im.Name ""))}}{{$im.Name}} {{end}}{{$im.Path | printf "%q"}}
{{end -}}
)
{{end}}

type {{$target}}Metadata struct {
	id         int    // required by reference
	Name       string `json:"-"` // required by reference (and toString)
	underlying string `json:"-"` // required by toString
	goType string `json:"-"`

{{ range $_, $f := $root.Target.Fields}}
	{{$f.Name}} {{$f.Type}}{{if (not (eq $f.Tag ""))}}  `{{$f.Tag}}`{{end -}}
{{end}}
}

{{range $_, $t := $root.Types}}{{with $name := ($t.Name)}}
{{if $t.NeedBuilder }}
{{if (not (eq "" $t.Doc))}}{{$t.Doc}}{{end}}
type {{$name}}Metadata struct {
{{range $_, $f := $t.Fields}}
	{{if (not (eq "" $f.Doc))}}{{$f.Doc}}{{end}}
	{{$f.Name}} {{$f.Type}}{{if (not (eq $f.Tag ""))}}  `{{$f.Tag}}`{{end -}}
{{end}}
}
{{else}}
{{if (not (eq "" $t.Doc))}}{{$t.Doc}}{{end}}
type {{$name}} struct {
{{range $_, $f := $t.Fields}}
	{{if (not (eq "" $f.Doc))}}{{$f.Doc}}{{end}}
	{{$f.Name}} {{$f.Type}}{{if (not (eq $f.Tag ""))}}  `{{$f.Tag}}`{{end -}}
{{end}}
}
{{end}}
{{end}}{{end}}
{{end}}{{end}}{{end -}}

--------------------------------------------------------------------------------

{{define "Stringer" -}}{{with $root := .}}{{with $target := ($root.Target.Name) -}}
// Generated by {{$root.GeneratedBy}} {{$root.SysArgs}}

package {{$root.PkgName}}

import (
	"fmt"
	"strings"
	"io"
)

func (t *_{{$target}}[R]) String() string {
	return ToString(t.ret)
}

func ToString(t {{$target}}Builder) string {
	b := new(strings.Builder)
	if err := t.write{{$target}}(b); err != nil {
		return fmt.Sprintf("invalid type: %T", t)
	}
	return b.String()
}

// default implementation or write {{$target}}
func (t *_{{$target}}[R]) write{{$target}}(w io.Writer) error {
	if t.metadata.Name != "" {
		if _, err := io.WriteString(w, t.metadata.Name); err != nil {
			return err
		}
	} else {
		if _, err := io.WriteString(w, t.metadata.underlying); err != nil {
			return err
		}
	}
	return nil
}

{{end}}{{end}}{{end -}}