{{define "Builder" -}}{{with $root := .}}{{with $target := ($root.Target) -}}
// Generated by github.com/podhmo/gos/seed {{$root.Args}}
package {{$root.PkgName}}

import (
	"fmt"
	"sync"
	"strings"
)

type {{$target}}Builder interface {
	Get{{$target}}Metadata() *{{$target}}Metadata
}

// Define{{$target}} names {{$target}} value.
func Define{{$target}}[T interface {
	{{$target}}Builder
	store{{$target}}(name string)
}](name string, t T) T {
	t.store{{$target}}(name)
	return t
}

type Builder struct {
	mu          	sync.Mutex
	named{{$target}}s  []{{$target}}Builder
	nameToIDMap map[string][]int
}

func New{{$target}}Builder() *Builder {
	return &Builder{nameToIDMap: map[string][]int{}}
}

// Each{{$target}} iterates named {{$target}}.
func (b *Builder) Each{{$target}}s(fn func({{$target}}Builder) error) error {
	for _, t := range b.named{{$target}}s {
		if err := fn(t); err != nil {
			return fmt.Errorf("error on %v -- %w", t, err) // TODO: use ToString()
		}
	}
	return nil
}

func (b *Builder) store{{$target}}(typ {{$target}}Builder) {
	val := typ.Get{{$target}}Metadata()
	val.id = -1
	if val.Name == "" {
		return
	}

	b.mu.Lock()
	defer b.mu.Unlock()
	id := len(b.named{{$target}}s)
	val.id = id
	b.named{{$target}}s = append(b.named{{$target}}s, typ)
	b.nameToIDMap[val.Name] = append(b.nameToIDMap[val.Name], id)
	// TODO: name conflict check
}

func (b *Builder) lookup{{$target}}(name string) {{$target}}Builder {
	b.mu.Lock()
	defer b.mu.Unlock()
	ids, ok := b.nameToIDMap[name]
	if !ok {
		b.nameToIDMap[name] = nil
		return nil
	}
	if len(ids) == 0 {
		return nil
	}

	// TODO: name conflict check
	return b.named{{$target}}s[ids[0]]
}


{{range $_, $t := $root.Types}}{{with $name := ($t.Metadata.Name)}}
{{if $t.Metadata.NeedBuilder }}
// {{$name}} builds {{$target}} for {{$name}}
func (b *Builder) {{$name}}({{if (not (eq $t.Metadata.Constructor nil))}}{{range $_,$a := $t.Metadata.Constructor.Args}}{{$a.Name | toLower}} {{if $a.Variadic}}...{{end}}{{$a.Type}},{{end}}{{end}}) *{{$name}}{{$target}} {
	t := &{{$name}}{{$target}}{
		{{$name}}Builder: &{{$name}}Builder[*{{$name}}{{$target}}]{
			_{{$target}}:    &_{{$target}}[*{{$name}}{{$target}}]{rootbuilder: b, metadata: &{{$target}}Metadata{Name: "", underlying: {{$name | printf "%q"}}}},
			metadata: &{{$name}}Metadata{
				{{if (not (eq $t.Metadata.Constructor nil))}}{{range $_,$a := $t.Metadata.Constructor.Args}}{{$a.Name}}: {{$a.Name | toLower}}, {{end}}{{end}}
			},
		},
	}
	t.ret = t
	return t
}

type {{$name}}{{$target}} struct {
	*{{$name}}Builder[*{{$name}}{{$target}}]
}

func (t *{{$name}}{{$target}}) GetMetadata() *{{$name}}Metadata {
	return t.metadata
}

type {{$name}}Builder[R {{$target}}Builder] struct {
	*_{{$target}}[R]
	metadata *{{$name}}Metadata
	ret R
}

// begin setter of {{$name}} ----------------------------------------
{{range $_, $f := $t.Metadata.Fields}}{{if (not (index $t.Metadata.Used $f.Name))}}
// {{$f.Name}} set Metadata.{{$f.Name}}
func (b *{{$name}}Builder[R]) {{$f.Name}}(value {{$f.Type}}) R {
	b.metadata.{{$f.Name}} = value
	return b.ret
}
{{end}}{{end}}
// end setter of {{$name}} ----------------------------------------

{{else}}
{{end}}
{{end}}{{end -}}

// internal {{$target}}

type _{{$target}}[R {{$target}}Builder] struct {
	metadata *{{$target}}Metadata
	ret      R

	rootbuilder *Builder
}

func (t *_{{$target}}[R]) Get{{$target}}Metadata() *{{$target}}Metadata {
	return t.metadata
}
func (t *_{{$target}}[R]) Doc(stmts ...string) R {
	t.metadata.Doc = strings.Join(stmts, "\n")
	return t.ret
}
func (t *_{{$target}}[R]) store{{$target}}(name string) {
	t.metadata.Name = name
	t.rootbuilder.store{{$target}}(t.ret)
}
{{end}}{{end}}{{end}}

----------------------------------------

{{define "Metadata" -}}{{with $root := .}}{{with $target := ($root.Target) -}}
package {{$root.PkgName}}

type {{$target}}Metadata struct {
	id         int    // required by reference
	Name       string `json:"-"` // required by reference (and toString)
	underlying string `json:"-"` // required by toString

	Doc string `json:"Doc"`
}

{{range $_, $t := $root.Types}}{{with $name := ($t.Metadata.Name)}}
{{if $t.Metadata.NeedBuilder }}
type {{$name}}Metadata struct {
{{- range $_, $f := $t.Metadata.Fields}}
	{{$f.Name}} {{$f.Type}}{{if (not (eq $f.Tag ""))}}  `{{$f.Tag}}`{{end}}
{{end -}}
}
{{else}}
type {{$name}} struct {
{{- range $_, $f := $t.Metadata.Fields}}
	{{$f.Name}} {{$f.Type}}{{if (not (eq $f.Tag ""))}}  `{{$f.Tag}}`{{end}}
{{end -}}
}
{{end}}
{{end}}{{end}}
{{end}}{{end}}{{end}}
