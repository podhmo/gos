{{define "Builder" -}}{{with $root := .}}{{with $target := ($root.Target)}}
package M

type {{$target}}Builder interface {
	Get{{$target}}Metadata *{{$target}}Metadata
}

func Define{{$target}}[T interface {
	{{$target}}Builder
	store{{$target}}(name string)
}](name string, t T) T {
	t.store{{$target}}(name)
	return t
}

type Builder struct {
	mu          sync.Mutex
	named{{$target}}s  []{{$target}}Builder
	nameToIDMap map[string][]int
}

func NewBuilder() *Builder {
	return &Builder{nameToIDMap: map[string][]int{}}
}

func (b *Builder) Each{{$target}}s(fn func({{$target}}Builder) error) error {
	for _, t := range b.named{{$target}}s {
		if err := fn(t); err != nil {
			return fmt.Errorf("error on %v -- %w", t, err) // TODO: use ToString()
		}
	}
	return nil
}

func (b *Builder) store{{$target}}(typ {{$target}}Builder) {
	val := typ.Get{{$target}}Metadata()
	val.id = -1
	if val.Name == "" {
		return
	}

	b.mu.Lock()
	defer b.mu.Unlock()
	id := len(b.named{{$target}}s)
	val.id = id
	b.named{{$target}}s = append(b.named{{$target}}s, typ)
	b.nameToIDMap[val.Name] = append(b.nameToIDMap[val.Name], id)
	// TODO: name conflict check
}

func (b *Builder) lookup{{$target}}(name string) {{$target}}Builder {
	b.mu.Lock()
	defer b.mu.Unlock()
	ids, ok := b.nameToIDMap[name]
	if !ok {
		b.nameToIDMap[name] = nil
		return nil
	}
	if len(ids) == 0 {
		return nil
	}

	// TODO: name conflict check
	return b.named{{$target}}s[ids[0]]
}


{{range $_, $t := $root.Types}}{{with $name := ($t.Metadata.Name)}}
{{if $t.Metadata.NeedBuilder }}
func (b *Builder) {{$name}}() *{{$name}}{{$target}} {
	t := &{{$name}}{{$target}}{
		{{$name}}Builder: &{{$name}}Builder[*{{$name}}]{Metadata: &{{$name}}Metadata{}},
	}
	t.ret = t
	return t
}
type {{$name}}{{$target}} struct {
	*{{$name}}Builder[*{{$name}}{{$target}}]
}

type {{$name}}Builder[R any] struct {
	Metadata *{{$name}}Metadata
	ret R
}
{{else}}
type {{$name}}{{$target}} struct {
}
{{end}}
{{end}}{{end}}
{{end}}{{end}}{{end}}

----------------------------------------

{{define "Metadata" -}}{{with $root := .}}{{with $target := ($root.Target)}}
package M

{{range $_, $t := $root.Types}}{{with $name := ($t.Metadata.Name)}}
type {{$name}}Metadata struct {
}
{{end}}{{end}}
{{end}}{{end}}{{end}}