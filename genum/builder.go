// Generated by github.com/podhmo/gos/genum/tools [-write -builder -metadata -pkgname genum]

package genum

import (
	"fmt"
	"strings"
	"sync"
)

type EnumBuilder interface {
	GetEnumMetadata() *EnumMetadata
}

// DefineEnum names Enum value.
func DefineEnum[T interface {
	EnumBuilder
	storeEnum(name string)
}](name string, t T) T {
	t.storeEnum(name)
	return t
}

type Builder struct {
	mu          sync.Mutex
	namedEnums  []EnumBuilder
	nameToIDMap map[string][]int
	Config      *Config
}

func NewEnumBuilder(config *Config) *Builder {
	return &Builder{
		nameToIDMap: map[string][]int{},
		Config:      config,
	}
}

// EachEnum iterates named Enum.
func (b *Builder) EachEnums(fn func(EnumBuilder) error) error {
	for _, t := range b.namedEnums {
		if err := fn(t); err != nil {
			return fmt.Errorf("error on %v -- %w", t, err) // TODO: use ToString()
		}
	}
	return nil
}

func (b *Builder) storeEnum(typ EnumBuilder) {
	val := typ.GetEnumMetadata()
	val.id = -1
	if val.Name == "" {
		return
	}

	b.mu.Lock()
	defer b.mu.Unlock()
	id := len(b.namedEnums)
	val.id = id
	b.namedEnums = append(b.namedEnums, typ)
	b.nameToIDMap[val.Name] = append(b.nameToIDMap[val.Name], id)
	// TODO: name conflict check
}

func (b *Builder) lookupEnum(name string) EnumBuilder {
	b.mu.Lock()
	defer b.mu.Unlock()
	ids, ok := b.nameToIDMap[name]
	if !ok {
		b.nameToIDMap[name] = nil
		return nil
	}
	if len(ids) == 0 {
		return nil
	}

	// TODO: name conflict check
	return b.namedEnums[ids[0]]
}

// IntEnum builds Enum for IntEnum
func (b *Builder) IntEnum(members ...*IntValue) *IntEnum {
	t := &IntEnum{
		IntEnumBuilder: &IntEnumBuilder[*IntEnum]{
			_Enum: &_Enum[*IntEnum]{rootbuilder: b, metadata: &EnumMetadata{Name: "", underlying: "int"}},
			metadata: &IntEnumMetadata{
				Members: mapslice(members, func(x *IntValue) *IntValueMetadata { return x.metadata }),
			},
		},
	}
	t.ret = t
	return t
}

type IntEnum struct {
	*IntEnumBuilder[*IntEnum]
}

func (t *IntEnum) GetMetadata() *IntEnumMetadata {
	return t.metadata
}

type IntEnumBuilder[R EnumBuilder] struct {
	*_Enum[R]
	metadata *IntEnumMetadata
}

// begin setter of IntEnum --------------------

// Default set Metadata.Default
func (b *IntEnumBuilder[R]) Default(value int) R {
	b.metadata.Default = value
	return b.ret
}

// end setter of IntEnum --------------------

// IntValue builds Enum for IntValue
func (b *Builder) IntValue(name string, value int) *IntValue {
	t := &IntValue{
		IntValueBuilder: &IntValueBuilder[*IntValue]{
			_Enum: &_Enum[*IntValue]{rootbuilder: b, metadata: &EnumMetadata{Name: "", underlying: "IntValue"}},
			metadata: &IntValueMetadata{
				Name: name, Value: value,
			},
		},
	}
	t.ret = t
	return t
}

type IntValue struct {
	*IntValueBuilder[*IntValue]
}

func (t *IntValue) GetMetadata() *IntValueMetadata {
	return t.metadata
}

type IntValueBuilder[R EnumBuilder] struct {
	*_Enum[R]
	metadata *IntValueMetadata
}

// begin setter of IntValue --------------------

// Doc set Metadata.Doc
func (b *IntValueBuilder[R]) Doc(value string) R {
	b.metadata.Doc = value
	return b.ret
}

// end setter of IntValue --------------------

// StringEnum builds Enum for StringEnum
func (b *Builder) StringEnum(members ...*StringValue) *StringEnum {
	t := &StringEnum{
		StringEnumBuilder: &StringEnumBuilder[*StringEnum]{
			_Enum: &_Enum[*StringEnum]{rootbuilder: b, metadata: &EnumMetadata{Name: "", underlying: "string"}},
			metadata: &StringEnumMetadata{
				Members: mapslice(members, func(x *StringValue) *StringValueMetadata { return x.metadata }),
			},
		},
	}
	t.ret = t
	return t
}

type StringEnum struct {
	*StringEnumBuilder[*StringEnum]
}

func (t *StringEnum) GetMetadata() *StringEnumMetadata {
	return t.metadata
}

type StringEnumBuilder[R EnumBuilder] struct {
	*_Enum[R]
	metadata *StringEnumMetadata
}

// begin setter of StringEnum --------------------

// Default set Metadata.Default
func (b *StringEnumBuilder[R]) Default(value string) R {
	b.metadata.Default = value
	return b.ret
}

// end setter of StringEnum --------------------

// StringValue builds Enum for StringValue
func (b *Builder) StringValue(value string) *StringValue {
	t := &StringValue{
		StringValueBuilder: &StringValueBuilder[*StringValue]{
			_Enum: &_Enum[*StringValue]{rootbuilder: b, metadata: &EnumMetadata{Name: "", underlying: "StringValue"}},
			metadata: &StringValueMetadata{
				Value: value,
			},
		},
	}
	t.ret = t
	return t
}

type StringValue struct {
	*StringValueBuilder[*StringValue]
}

func (t *StringValue) GetMetadata() *StringValueMetadata {
	return t.metadata
}

type StringValueBuilder[R EnumBuilder] struct {
	*_Enum[R]
	metadata *StringValueMetadata
}

// begin setter of StringValue --------------------

// Name set Metadata.Name
func (b *StringValueBuilder[R]) Name(value string) R {
	b.metadata.Name = value
	return b.ret
}

// Doc set Metadata.Doc
func (b *StringValueBuilder[R]) Doc(value string) R {
	b.metadata.Doc = value
	return b.ret
}

// end setter of StringValue --------------------

// internal Enum

type _Enum[R EnumBuilder] struct {
	metadata *EnumMetadata
	ret      R

	rootbuilder *Builder
}

func (t *_Enum[R]) GetEnumMetadata() *EnumMetadata {
	return t.metadata
}
func (t *_Enum[R]) Doc(stmts ...string) R {
	t.metadata.Doc = strings.Join(stmts, "\n")
	return t.ret
}

func (t *_Enum[R]) storeEnum(name string) {
	t.metadata.Name = name
	t.rootbuilder.storeEnum(t.ret)
}

// footer. ----
func mapslice[S, D any](src []S, conv func(S) D) []D {
	dst := make([]D, len(src))
	for i, x := range src {
		dst[i] = conv(x)
	}
	return dst
}
